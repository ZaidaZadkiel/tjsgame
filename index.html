<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
      #info {
        color: white;
      	position: absolute;
      	top: 10px;
      	width: 100%;
      	text-align: left;
      	z-index: 100;
        font-family: monospace;
      	display:block;
      }
		</style>
	</head>
	<body>
    <div id="info">Description</div>

		<script type="module">
      import * as THREE from 'https://cdn.skypack.dev/three@0.134.0';

			const scene    = new THREE.Scene();
			const camera   = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			const renderer = new THREE.WebGLRenderer();

			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

      import { OrbitControls }   from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/controls/OrbitControls.js';
      import { GLTFLoader }      from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/loaders/GLTFLoader.js';
      import { RoomEnvironment } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/environments/RoomEnvironment.js';

      const controls  = new OrbitControls(camera, renderer.domElement);
      const imgloader = new THREE.TextureLoader();
			const geometry  = new THREE.BoxGeometry();
			const material  = new THREE.MeshBasicMaterial({map: imgloader.load("img/wall.jpg") });
			const clock     = new THREE.Clock();

			// movement - please calibrate these values
			var xSpeed = 0.1;
			var ySpeed = 0.1;

      material.flatShading = true;

			const cube = new THREE.Mesh( geometry, material );
			scene.add( cube );

      const linematerial = new THREE.LineBasicMaterial( { color: 0x0000ff } );
      const points = [
	      new THREE.Vector3( -10,  -10,  0 ) ,
	      new THREE.Vector3( -10,   10,  0 ) ,
	      new THREE.Vector3(  10,   10,  0 ) ,
	      new THREE.Vector3(  10,  -10,  0 ) ,
	      new THREE.Vector3( -10,  -10,  0 )
			];

      const linegeo = new THREE.BufferGeometry().setFromPoints( points );
      const line    = new THREE.Line( linegeo, linematerial );
      scene.add( line );

			camera.position.z = 20;

      const environment    = new RoomEnvironment();
      const pmremGenerator = new THREE.PMREMGenerator( renderer );
			const loader         = new GLTFLoader();
      scene.background     = new THREE.Color( 0xbbbbbb );
			scene.environment    = pmremGenerator.fromScene( environment ).texture;
			const movement       = [0,0]; //movement second deltas


			console.log("flag");
			var mixer = [];

      const loadGLTFPhilez = (paths) => {
				if(!Array.isArray(paths)) {
					console.log("Error with loading paths");
					return null;
				}

				paths.forEach((path, i) => {
					console.log("path index", i, `mod/${path}`);

					loader.load(
						`mod/${path}`,
						( gltf ) => {
							mixer[i] = new THREE.AnimationMixer( gltf.scene );
							console.log(mixer[i]);
							if(Array.isArray(gltf.animations) && gltf.animations[0]){
								var action = mixer[i].clipAction( gltf.animations[ 0 ] );
								action.play();
							}

			      	scene.add( gltf.scene );
			      },
						(result) => {
							//this callback after loading philez
							console.log(`loled path mod/${path}`)
						},
						( error ) => {
			      	console.error( error );
			      }
					); // loader.load(

				});

			} // loadGLTFPhilez()

      const debugcam = () => {
        var nice = [];
        nice[0] = "x:" + camera.rotation.x.toFixed(6).padStart(10, '0');
        nice[1] = "y:" + camera.rotation.y.toFixed(6).padStart(10, '0');
        nice[2] = "z:" + camera.rotation.z.toFixed(6).padStart(10, '0');
				nice[3] = "posx:" + cube.position.x.toFixed(6).padStart(10, '0');
				nice[4] = "posy:" + cube.position.y.toFixed(6).padStart(10, '0');
				nice[5] = "posz:" + cube.position.z.toFixed(6).padStart(10, '0');
        document.getElementById("info").innerHTML=nice.join('<br/>');
      }

			//
			loadGLTFPhilez(
				[
					"stage.glb" ,
					"lilhouse.glb"
				]
			);

			console.log({cube});

			document.addEventListener(
				"keydown",
				(event) => {
						//hardcoder4lyf bby
						switch(event.which){
							case 87: movement[0] =  0.1; break;
							case 83: movement[0] = -0.1; break;
							case 65: movement[1] = -0.1; break;
							case 68: movement[1] =  0.1; break;
						}
				},
				false
			);

			document.addEventListener(
				"keyup",
				(event) => {
						//hardcoder4lyf bby
						switch(event.which){
							case 87:
							case 83: movement[0] = 0; break;
							case 65:
							case 68: movement[1] = 0; break;
						}
				},
				false
			);

			const animate = function () {
				requestAnimationFrame( animate );
				cube.position.x += movement[1];
				cube.position.y += movement[0];

				if ( mixer ) mixer.forEach((mix) => {
					mix.update( clock.getDelta() );
				});

				renderer.render( scene, camera );
        debugcam();
			};

			animate();
		</script>
	</body>
</html>
